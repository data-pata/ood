design decisions (sem 3)

    Startup 
        Controller only creates the model objects for increased cohesion. 
        An IntegrationHandler class, is introduced, that interfaces to peripheral units and external systems for increased encapsulation and lower coupling. This design is made with the facade pattern in mind. The controller then won't reference each and every other system or peripheral but need only to communicate with the layers facade - IntegrationHandler.

    Pay operation
        I do not encapsulate cost calculation of the sale into it's own class. Partly because all cost, as opposed to the car rental case study, hÃ¤nfÃ¶rs only from the items in the sale and nothing else. Partly because each item's cost data is tightly coupled to the item itself so extracting it into a new class would negatively affect the code cohesiveness and understandability.

        The receipt class will reside in the integration layer because it is the lower layer it used and it is a data class or rather a data represention class not containing business logic. A rule of thumb is that the model objects should be agnostic to how their data will be represented in database etc.
        The printer recieves all data needed to print a receipt but I left out the string formating for obvious reasons. 


    For further expandability and/or separation of concerns, interlayer dependencies exist only between one class in each layer. For example, class Controller is only dependent on the class "Model" in the model package. This class therefore acts as a controller and public interface for the package. This brings 1hlow coupling and easier maintainance between the two layers. (Albeit, it may decrease the readability of the code??)
    Also, it doesn't seem like properly separated concerns when a class in the controller layer keeps a model or integration reference as an instance variable. Those variable ought to reside in their respective layers. 

    This is in line with the facade pattern?? is it? and the facade classes are singletons making sure they are only instantiated once and are easy to call. 

    In early development or prototyping the controller class may seem redundant if it simply invokes
    corresponding methods in the model-controller class. Why not simply let the view bypass the controller?
    Doing so would be a mistake since the system would loose it's flexibilty e.g. to introduce new packages more aptly called by an independent controller outside of the model layer. 
    
    I discussed this solution and it was argued that my class called model is really a controller and should reside in the controller layer. I concurr it functions as a controller and that an Ã¶vervÃ¤gning must be made. Firstly if it's moved to the controller layer some of the business logic  
    busines logic = application logic + domain logic 
        If any business logic in controller it's the application logic. Domain logic should never be placed in the model layer.

        https://softwareengineering.stackexchange.com/questions/26438/how-much-business-logic-should-be-allowed-to-exist-in-the-controller-layer 

    "When encapsulation, cohesion and coupling are used
    to make layers independent, it becomes easy to maintain the layers and to divide development
    of different layers between developers. It is also easy to reuse code, since a layer can provide
    a well-designed public interface, callable from any code in a higher layer."

    design decision: check external product catalog and retrieve info first or current sale for duplicate items?
        check current sale first coz it's quick and minimizes data transfer. If key (EAN) not present then search the catalog.  


implementation decisions
    Hashmap for quickest access and uniquely identifible values (items) by EAN-code as key.  
    By utilizing the map interface a change of implementation is easily done. This enables switching to a LinkedHashMap implementation later on wich is useful if e.g. ordering by insertion or access of the entered products is required.
    But you can possibly convert all values in a HashMap to a list and simply sort it. 
    http://www.javapractices.com/topic/TopicAction.do?Id=65

    INPUT VALIDATION i view ?! 

    Writing clear code for example this:
        var item = lineItems.get(ean);
        item.incrementQuantity();
        updateRunningTotal();
    Instead of this:
        lineItems.get(ean).incrementQuantity();
    
    OBSERVERA:
    keeping ean of last entered item instead of reference to item itself to avoid data corruption etc. minimize references to an object.
    is this stateful operation proper or maybe should the view handle what ean is really meant - probably since the cashier has a list 
    
    Eager implementation of running total updates meaning that the runningTotal variable always maintains correct state. Instead of lazy and stateless implemention whereas the running total is calculated only whenever it is required from outside. Since this is a stateful application overall, an eager stateful implementation of the running total is most consistent.

    Strings to view current state of sale. In production the application would use serialization or data transfer objects to send data inbetween layers. For example, the view would query or recieve as return value a data object and would unpack and turn it into display content. Now instead a string representing the sale object state is returned from the lower layers. This is simply printed by the view.
    
    Testing with doubles note that for assertEquals: Equality imposed by this method is consistent with Double.equals(Object) and Double.compare(double, double).
    There is no handling of under-/overflow of doubles in the program. In Java, the double type is not like integers with wraparounds. Instead a big enough double will take on MAX_VALUE or MIN_VALUE and if increased or decreased even more take on the value POSITIVE_INFINITY or NEGATIVE_INFINITY. The two latter ones are kinds of NaN.
    Anyways the amounts allowed are > 0 and <= 10e9, just too stay of the edge. If, against assumption, this program would be used at a rich people store or with a lowly rated currency and a sale would rack up to over a billion that may be handled then.  